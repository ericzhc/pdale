/*
*********************************************************************************************************
*                                               uC/HTTPs
*                                 HyperText Transfer Protocol (server)
*
*                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
*
*                   All rights reserved.  Protected by international copyright laws.
*                   Knowledge of the source code may not be used to write a similar
*                   product.  This file may only be used in accordance with a license
*                   and should not be redistributed in any way.
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*
*                                              HTTP SERVER
*
* Filename      : http-s.c
* Version       : V1.85
* Programmer(s) : JDH
*********************************************************************************************************
*
*  This server is designed to work well with an embedded system that does not have PERL and the other
*  "niceties" that are on a larger UNIX or NT server environment.  GET and POST requests are supported.
*
*  For GET, if the string is "GET / ", then index.htm is the response, if the string is "GET /FileName",
*  then that file is used as the response.  If the file suffix is .htm or .html, then the server will
*  parse the file prior to sending it to the client.  If the syntax ${TEXT_STRING} is found within the
*  file, then the string TEXT_STRING is passed to an application-specific function and the all characters
*  from the opening '$' to the closing '}' are omitted and replaced with whatever the application-
*  specific code wants to replace it with.
*
*  For POST, (generated by the HTML "form" submission), the input is assumed to be formatted as
*  "POST /action" where 'action' defines what the server is to do with the next incoming TCP stream. This
*  next stream is the data entered through the user interface presented by the HTML file that contains
*  the form mechanism (the cgi name/value pairs).  It can simply be an HTML file that is processed in the
*  same way as was discussed above for the GET command.
*
*  Now a simple example of the above discussion.
*  Assume we have a file called myip.htm on the target that looks like this:
*
*  <html><body><center>
*  This system's IP address is ${My_IP_Address}
*  </center></body></html>
*
*  When a client attaches to this server and requests (via GET) myip.htm, the server will parse the file,
*  find the ${My_IP_Address} syntax and pass the string "My_IP_Address" into an application specific
*  function called HTTPs_ValRx().  That function will then build a replacement text string that the
*  server will give to the client in place of the ${My_IP_Address} text.  The file seen by the client
*  would look something like this:
*
*  <html><body><center>
*  This system's IP address is 135.17.115.215
*  </center></body></html>
*
*  Similarly, if the action of a form is a .htm file, the server will first parse the incoming name/value
*  list and pass each name value pair into an app-specific function called HTTPs_ValRx() to allow the
*  application to properly parse the data entered by the user of the client.  Then the HTML file
*  specified as the action will be processed as discussed above and sent to the client.
*
*  Note that this server does not define any syntax within the ${}.  This is 100% application-specific
*  and can be used for simple variable name conversion or something more elaborate if necessary.
*
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*                                             INCLUDE FILES
*********************************************************************************************************
*/

#define    HTTPs_MODULE
#include  <includes.h>
#include  <app_cfg.h>
#include  <fs_api.h>
#include  <net.h>
#include  <http-s.h>

/*
*********************************************************************************************************
*                                                DEFINES
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*                                           GLOBAL VARIABLES
*********************************************************************************************************
*/

static  CPU_INT32U  HTTPs_ReqCnt;                               /* Used to keep track of the total number of HTTP       */
                                                                /* accesses that have been made on the server.          */


/*
*********************************************************************************************************
*                                           INITIALIZED DATA
*********************************************************************************************************
*/

                                                                /* HTTP_Ver[]:                                          */
                                                                /* Used for verbose display of server and client        */
                                                                /* supported HTTP versions. Array is indexed into by    */
                                                                /* the HTTP_VER_YYY values. */
const  CPU_CHAR             *HTTPs_Ver[]    = {(CPU_CHAR *)"Unsupported",
                                               (CPU_CHAR *)"HTTP/0.9",
                                               (CPU_CHAR *)"HTTP/1.0",
                                               (CPU_CHAR *)"HTTP/1.1"};

                                                                /* HTTP_Method[]:                                       */
                                                                /* Used for verbose display of incoming method.  This   */
                                                                /* array is indexed into by the HTTP_METHOD_YYY values. */
const  CPU_CHAR             *HTTPs_Method[] = {(CPU_CHAR *)"Unsupported",
                                               (CPU_CHAR *)"GET",
                                               (CPU_CHAR *)"HEAD",
                                               (CPU_CHAR *)"POST"};

const  HTTPs_STATUS_STRUCT   HTTPs_Status[] = {
    {200,  (CPU_CHAR *)"OK"                   },
    {201,  (CPU_CHAR *)"Created"              },
    {202,  (CPU_CHAR *)"Accepted"             },
    {204,  (CPU_CHAR *)"No Content"           },
    {301,  (CPU_CHAR *)"Moved Permanently"    },
    {302,  (CPU_CHAR *)"Moved Temporarily"    },
    {304,  (CPU_CHAR *)"Not Modified"         },
    {400,  (CPU_CHAR *)"Bad Request"          },
    {401,  (CPU_CHAR *)"Unauthorized"         },
    {403,  (CPU_CHAR *)"Forbidden"            },
    {404,  (CPU_CHAR *)"Not Found"            },
    {500,  (CPU_CHAR *)"Internal Server Error"},
    {501,  (CPU_CHAR *)"Not Implemented"      },
    {502,  (CPU_CHAR *)"Bad Gateway"          },
    {503,  (CPU_CHAR *)"Service Unavailable"  },
};

const  HTTPs_MIME_TYPE_STRUCT  HTTPs_MimeType[] = {
    {(CPU_CHAR *)"*",      (CPU_CHAR *)"application/octet-stream"},
    {(CPU_CHAR *)"class",  (CPU_CHAR *)"application/octet-stream"},
    {(CPU_CHAR *)"pdf",    (CPU_CHAR *)"application/pdf"         },
    {(CPU_CHAR *)"zip",    (CPU_CHAR *)"application/zip"         },
    {(CPU_CHAR *)"gif",    (CPU_CHAR *)"image/gif"               },
    {(CPU_CHAR *)"jpeg",   (CPU_CHAR *)"image/jpeg"              },
    {(CPU_CHAR *)"jpg",    (CPU_CHAR *)"image/jpeg"              },
    {(CPU_CHAR *)"png",    (CPU_CHAR *)"image/png"               },
    {(CPU_CHAR *)"htm",    (CPU_CHAR *)"text/html"               },
    {(CPU_CHAR *)"html",   (CPU_CHAR *)"text/html"               },
    {(CPU_CHAR *)"js",     (CPU_CHAR *)"text/javascript"         },
    {(CPU_CHAR *)"txt",    (CPU_CHAR *)"text/plain"              },
    {(CPU_CHAR *)"css",    (CPU_CHAR *)"text/stylesheet"         },
    {(CPU_CHAR *) 0,       (CPU_CHAR *) 0                        }
};


/*
*********************************************************************************************************
*                                          HTTPs_GetMimeType()
*
* Description : Return MIME type according to file name extension.
*
* Argument(s) : FileName        string containing the name to the file.
*
* Return(s)   :                 string containing the MIME type.
*
* Caller(s)   : Various.
*********************************************************************************************************
*/

static  CPU_CHAR  *HTTPs_GetMimeType (CPU_CHAR  *file_name)
{
    CPU_CHAR    *last_dot_ptr;
    CPU_CHAR    *mime_type;
    CPU_INT32S   str_result;
    CPU_INT32U   ix;


    mime_type    = HTTPs_MimeType[0].MimeType;
    last_dot_ptr = Str_Char_Last(file_name, '.');
    if (last_dot_ptr == (CPU_CHAR *)0) {
        return (mime_type);
    } else {
        last_dot_ptr++;
    }

    ix = 0;
    while (HTTPs_MimeType[ix].FileExt != (CPU_CHAR *)0) {
        str_result = Str_Cmp(last_dot_ptr, HTTPs_MimeType[ix].FileExt);
        if (str_result == 0) {
            mime_type = HTTPs_MimeType[ix].MimeType;
            break;
        }
        ix++;
    }
    return (mime_type);
}


/*
*********************************************************************************************************
*                                              HTTPs_Tx()
*
* Description : Transmit data to TCP socket, handling transient errors and incomplete buffer transmit.
*
* Argument(s) : sock_id         TCP socket ID.
*               net_buf         buffer to send.
*               net_buf_len     length of buffer to send.
*               net_err         contains error message returned.
*
* Return(s)   : DEF_FAIL        transmission failed.
*               DEF_OK          transmission successful.
*
* Caller(s)   : Various.
*********************************************************************************************************
*/

static  CPU_BOOLEAN  HTTPs_Tx (CPU_INT32S   sock_id,
                               CPU_CHAR    *net_buf,
                               CPU_INT16U   net_buf_len,
                               NET_ERR     *net_err)
{
    CPU_CHAR     *tx_buf;
    CPU_INT16S    tx_buf_len;
    CPU_INT16S    tx_len;
    CPU_INT16S    tx_len_tot;
    CPU_INT32U    tx_retry_cnt;
    CPU_BOOLEAN   tx_done;
    CPU_BOOLEAN   tx_dly;


    tx_len_tot   = 0;
    tx_retry_cnt = 0;
    tx_done      = DEF_NO;
    tx_dly       = DEF_NO;

    while ((tx_len_tot   <  net_buf_len)            &&          /* While tx tot len < buf len ...   */
           (tx_retry_cnt <  HTTPs_CFG_MAX_TX_RETRY) &&          /* ... & tx retry   < MAX     ...   */
           (tx_done      == DEF_NO)) {                          /* ... & tx NOT done;         ...   */

        if (tx_dly == DEF_YES) {                                /* Dly tx, if req'd.                */
            HTTPs_OS_TxDly();
        }

        tx_buf     = net_buf     + tx_len_tot;
        tx_buf_len = net_buf_len - tx_len_tot;
        tx_len     = NetSock_TxData(sock_id,                    /* ... tx data.                     */
                                    tx_buf,
                                    tx_buf_len,
                                    NET_SOCK_FLAG_NONE,
                                    net_err);
        switch (*net_err) {
            case NET_SOCK_ERR_NONE:
                 if (tx_len > 0) {                              /* If          tx len > 0, ...      */
                     tx_len_tot += tx_len;                      /* ... inc tot tx len.              */
                     tx_dly      = DEF_NO;
                 } else {                                       /* Else dly next tx.                */
                     tx_dly      = DEF_YES;
                 }
                 tx_retry_cnt = 0;
                 break;

            case NET_SOCK_ERR_NOT_USED:
            case NET_SOCK_ERR_INVALID_TYPE:
            case NET_SOCK_ERR_INVALID_FAMILY:
            case NET_SOCK_ERR_INVALID_STATE:
                 tx_done = DEF_YES;
                 break;

            case NET_ERR_TX:                                    /* If transitory tx err, ...    */
            default:
                 tx_dly = DEF_YES;                              /* ... dly next tx.             */
                 tx_retry_cnt++;
                 break;
        }
    }

    if (*net_err != NET_SOCK_ERR_NONE) {
        return (DEF_FAIL);
    }
    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                           HTTPs_TxHTTPHdr()
*
* Description : Send HTTP information header preceding any document requested.
*
* Argument(s) : ConnInfo            structure containing information about the HTTP connection.
*               Status              status of the request.
*               ContentMimeType     MIME type of the document.
*               ContentLen          length of the document.
*
* Return(s)   : DEF_FAIL        header transmission failed.
*               DEF_OK          header transmission successful.
*
* Caller(s)   : Various.
*
* Note(s)     : Uses the HTTPs_Status[] table to build a response destined for the client.
*               Refer to section 6.1 of RFC-2068 for details.
*********************************************************************************************************
*/

static  CPU_BOOLEAN  HTTPs_TxHTTPHdr (HTTPs_CONN_INFO  *conn_info,
                                      CPU_INT32U        status,
                                      CPU_CHAR         *content_mime_type,
                                      CPU_INT32U        content_len)
{
    CPU_CHAR    buf[HTTPs_MAX_PKT_SIZE + 1];
    CPU_INT32U  buf_len;
    NET_ERR     net_err;


    buf_len = Str_FmtPrint((char *)buf, HTTPs_MAX_PKT_SIZE,
                             HTTPs_HTTP_HEADER_FMT,
                            (char *)conn_info->ServerVer,
                             HTTPs_Status[status].Code,
                             HTTPs_Status[status].Reason,
                             content_mime_type,
                             content_len);

    HTTPs_Tx(conn_info->SockID, buf, buf_len, &net_err);
    if (net_err != NET_SOCK_ERR_NONE) {
        return (DEF_FAIL);
    }
    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                       HTTPs_TxFileNotFoundMsg()
*
* Description : Send "File Not Found (401)" answer to the HTTP client.
*
* Argument(s) : conn_info       structure containing information about the HTTP connection.
*
* Return(s)   : DEF_FAIL        message transmission failed.
*               DEF_OK          message transmission successful.
*
* Caller(s)   : Various.
*********************************************************************************************************
*/

static  CPU_BOOLEAN  HTTPs_TxFileNotFoundMsg (HTTPs_CONN_INFO  *conn_info)
{
    CPU_CHAR     *buf;
    CPU_INT32U    buf_len;
    CPU_CHAR     *mime_type;
    NET_ERR       net_err;
    CPU_BOOLEAN   err;


    buf       = (CPU_CHAR *)HTTPs_CFG_ERR_MSG_HTML_NOT_FOUND;
    buf_len   = Str_Len((CPU_CHAR *)HTTPs_CFG_ERR_MSG_HTML_NOT_FOUND);
    mime_type = HTTPs_GetMimeType((CPU_CHAR *)".html");

    err = HTTPs_TxHTTPHdr(conn_info, HTTP_STATUS_NOT_FOUND, mime_type, buf_len);
    if (err == DEF_FAIL) {
        return (DEF_FAIL);
    }

    HTTPs_Tx(conn_info->SockID, buf, buf_len, &net_err);
    if (net_err != NET_SOCK_ERR_NONE) {
        return (DEF_FAIL);
    }
    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                         HTTPs_HexDigitToInt()
*
* Description : Convert HEX digit to integer value.
*
* Argument(s) : hex_digit       character representation of hex digit (NOT case sensitive).
*
* Return(s)   :                 integer representation of the hez digit.
*
* Caller(s)   : HTTPs_ProcessCGIList().
*********************************************************************************************************
*/

static  CPU_CHAR  HTTPs_HexDigitToInt (CPU_CHAR  hex_digit)
{
    if ((hex_digit >= '0' && hex_digit <= '9')) {
        return (hex_digit - '0');
    }

    if ((hex_digit >= 'A' && hex_digit <= 'F')) {
        return (hex_digit - 'A');
    }

    if ((hex_digit >= 'a' && hex_digit <= 'f')) {
        return (hex_digit - 'a');
    }

    return ((CPU_CHAR)0);
}


/*
*********************************************************************************************************
*                                        HTTPs_ProcessCGIList()
*
* Description : Parse HTTP variable-value list.
*
* Argument(s) : ValList         string containing the variable-value list.
*
* Return(s)   : DEF_FAIL        data process failed.
*               DEF_OK          data process successfull.
*
* Caller(s)   : HTTPs_ProcessReq().
*
* Note(s)     : The input string from the HTML form has a few ugly details to deal with.
*               The format of the string is:  "name1=value1&name2=value2"
*               where "namex" is the name assigned in the form for a particular piece of input and
*               "valuex" is what was entered by the user of the form.
*
*               The ampersand (&) is the delimiter between variable assignments.  Any character can be
*               written as a percent sign followed by a 2-digit hex value that represents the actual
*               character.  If a '+' sign is on the line, then it should be converted to a space.
*********************************************************************************************************
*/

static  CPU_BOOLEAN  HTTPs_ProcessCGIList (CPU_CHAR  *val_list)
{
    CPU_CHAR  *in_ptr;
    CPU_CHAR  *out_ptr;
    CPU_CHAR  *amp_ptr;
    CPU_CHAR  *eq_ptr;


                                                                /* The incoming list may have other HTTPish stuff       */
                                                                /* prepended to it, so strip it off by searching for    */
                                                                /* the first '=' sign, then backing up to either the    */
                                                                /* beginning, or the first instance of a CR or LF.      */
    in_ptr = Str_Char(val_list, '=');
    if (in_ptr != (CPU_CHAR *)0) {
        while ((*in_ptr != '\n') &&
               (*in_ptr != '\r') &&
               (in_ptr != val_list)) {
            in_ptr--;
        }
        if ((*in_ptr == '\r') ||
            (*in_ptr == '\n')) {
            val_list = in_ptr + 1;
        } else {
            val_list = in_ptr;
        }
    }

                                                                /* Terminate the incoming name list when a CR or LF is  */
                                                                /* found.                                               */
    in_ptr = Str_Char(val_list, '=');
    if (in_ptr != (CPU_CHAR *)0) {
        while (*in_ptr) {
            if ((*in_ptr == '\r') ||
                (*in_ptr == '\n')) {
                *in_ptr = (CPU_CHAR)0;
                break;
            }
            in_ptr++;
        }
    }

                                                                /* First convert + and %xx.                             */
    in_ptr  = val_list;
    out_ptr = val_list;
    while (*in_ptr != (CPU_CHAR)0) {
        if (*in_ptr == '+') {
            *out_ptr = ' ';
        } else if (*in_ptr == '%') {
            *out_ptr = HTTPs_HexDigitToInt(in_ptr[1] * 0x10);
            *out_ptr = HTTPs_HexDigitToInt(in_ptr[2] * 0x01);
            in_ptr  += 2;
        } else {
            *out_ptr = *in_ptr;
        }
        in_ptr++;
        out_ptr++;
    }

                                                                /* Now parse for the name=var& strings.                 */
    eq_ptr  = Str_Char(val_list, '=');
    amp_ptr = Str_Char(val_list, '&');
    if (eq_ptr == (CPU_CHAR *)0) {
        return (DEF_FAIL);
    }

    while (eq_ptr != (CPU_CHAR *)0) {
        *eq_ptr = (CPU_CHAR)0;
        if (amp_ptr != (CPU_CHAR *)0) {
            *amp_ptr = (CPU_CHAR)0;
        }

        HTTPs_ValRx(val_list, eq_ptr + 1);
        if (amp_ptr == (CPU_CHAR *)0) {
            break;
        }

        val_list = amp_ptr + 1;
        eq_ptr   = Str_Char(val_list, '=');
        amp_ptr  = Str_Char(val_list, '&');
    }
    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                        HTTPs_ProcessHTMLFile()
*
* Description : Process any embedded variable in HTML file before send it to the client.
*
* Argument(s) : conn_info       structure containing information about the HTTP connection.
*               file_name       name of the HTML file.
*
* Return(s)   : DEF_FAIL        document transmission failed.
*               DEF_OK          document transmission successful.
*
* Caller(s)   : HTTPs_Connection().
*
* Note(s)     : For each line in the file, look for ${YYY} where YYY is some string to be operated on.
*               If not found in the line, then just pump out the line as is; if found, then pass the
*               string to the HTTPs_ValReq() function to allow it to make some kind of
*               conversion based on some internal state or variable.
*********************************************************************************************************
*/

static  CPU_BOOLEAN  HTTPs_ProcessHTMLFile (HTTPs_CONN_INFO  *conn_info, CPU_CHAR  *file_name)
{
    FS_FILE      *file;
    CPU_CHAR     *file_buf;
    CPU_CHAR     *file_buf_ptr;
    CPU_INT32S    file_buf_len;
    CPU_CHAR     *net_buf;
    CPU_CHAR     *net_buf_ptr;
    CPU_INT32S    net_buf_len;
    CPU_CHAR     *val_buf;
    CPU_INT32S    val_buf_len;
    CPU_CHAR     *var_start;
    CPU_CHAR     *var_end;
    CPU_CHAR     *mime_type;
    CPU_INT32U    StartTokLen;
    CPU_INT32U    StopTokLen;
    CPU_INT32S    offset;
    CPU_INT32S    tx_size;
    NET_ERR       net_err;
    CPU_BOOLEAN   err;
    CPU_INT32U    file_size;


    StartTokLen = Str_Len((CPU_CHAR *)HTTPs_TOKEN_VAR_START);
    StopTokLen  = Str_Len((CPU_CHAR *)HTTPs_TOKEN_VAR_STOP );

                                                                /* Open file.                                           */
    file        = FS_FOpen((char *)file_name, "r");

    if (file == (FS_FILE *)0) {
        err = HTTPs_TxFileNotFoundMsg(conn_info);
        return (DEF_FAIL);
    }

    file_size =  FS_GetFileSize(file);                          /* Get file size.                                       */
                                                                /* Allocate buffer.                                     */
    file_buf  = (CPU_CHAR *)Mem_Malloc(file_size + 1);
    if (file_buf == (CPU_CHAR *)0) {
        return (DEF_FAIL);
    }

                                                                /* Read file.                                           */
    file_buf_len = FS_FRead(file_buf, 1, file_size, file);
    FS_FClose(file);
    if (file_buf_len != file_size) {
        Mem_Free(file_buf);
        return (DEF_FAIL);
    }
    file_buf[file_buf_len] = (CPU_CHAR)0;

                                                                /* Find TX size. TX size = (file - var + val) sizes.    */

                                                                /* Parse the file to find ${YYY} tokens.  Replace them  */
                                                                /* with the application-specific value and compute the  */
                                                                /* new file size (TX size).                             */
    net_buf_len  = file_buf_len;
    file_buf_ptr = file_buf;
    var_start    = Str_Str(file_buf_ptr, (CPU_CHAR *)HTTPs_TOKEN_VAR_START);
    var_end      = Str_Str(var_start,    (CPU_CHAR *)HTTPs_TOKEN_VAR_STOP);

    while ((var_start != (CPU_CHAR *)0) &&
           (var_end   != (CPU_CHAR *)0) &&
          ((var_end - (var_start + StartTokLen)) <= HTTPs_CFG_MAX_VAR_LEN)) {
       *var_end = (CPU_CHAR)0;
        val_buf = (CPU_CHAR *)0;
        err     =  HTTPs_ValReq(var_start + StartTokLen, &val_buf, HTTPs_CFG_MAX_VAL_LEN);
        if (err == DEF_FAIL) {
            val_buf = (CPU_CHAR *)"NULL";
        }
       *var_end = HTTPs_TOKEN_VAR_STOP[0];

        val_buf_len = Str_Len(val_buf);
        if (val_buf_len > HTTPs_CFG_MAX_VAL_LEN) {
            val_buf_len = HTTPs_CFG_MAX_VAL_LEN;
        }

        net_buf_len  += val_buf_len - (var_end + StopTokLen - var_start);
        file_buf_ptr  = var_end + StopTokLen;
        var_start     = Str_Str(file_buf_ptr, (CPU_CHAR *)HTTPs_TOKEN_VAR_START);
        var_end       = Str_Str(var_start,    (CPU_CHAR *)HTTPs_TOKEN_VAR_STOP );
    }

                                                                /* Allocate TX buffer.                                  */
    net_buf = (CPU_CHAR *)Mem_Malloc(net_buf_len + 1);
    if (net_buf == (CPU_CHAR *)0) {
        return (DEF_FAIL);
    }

                                                                /* Parse the file to find ${YYY} tokens.  Replace them  */
                                                                /* with the application-specific value.                 */
    file_buf_ptr = file_buf;
    net_buf_ptr  = net_buf;
    while ((file_buf_ptr < (file_buf + file_buf_len)) &&
           (net_buf_ptr  < (net_buf  + net_buf_len))) {
                                                                /* Search for a ${YYY} token.                           */
        var_start = Str_Str(file_buf_ptr, (CPU_CHAR *)HTTPs_TOKEN_VAR_START);
        var_end   = Str_Str(var_start,    (CPU_CHAR *)HTTPs_TOKEN_VAR_STOP );
        if ((var_start == (CPU_CHAR *)0) ||
            (var_end   == (CPU_CHAR *)0) ||
           ((var_end - var_start - StartTokLen) > HTTPs_CFG_MAX_VAR_LEN)) {
                                                                /* No valid token until the end of file.                */
                                                                /* Copy the remaining of the file.                      */
            offset = (net_buf + net_buf_len - net_buf_ptr);
            Mem_Copy(net_buf_ptr, file_buf_ptr, offset);
            file_buf_ptr += offset;
            net_buf_ptr  += offset;
        } else {
                                                                /* Copy the file until the token.                       */
            offset = (var_start - file_buf_ptr);
            Mem_Copy(net_buf_ptr, file_buf_ptr, offset);
            net_buf_ptr  += offset;
            file_buf_ptr += offset;

                                                                /* Request to value of the token to the application.    */
           *var_end = (CPU_CHAR  )0;
            val_buf = (CPU_CHAR *)0;
            err     =  HTTPs_ValReq(var_start + StartTokLen, &val_buf, HTTPs_CFG_MAX_VAL_LEN);
            if (err == DEF_FAIL) {
                val_buf = (CPU_CHAR *)"NULL";
            }
           *var_end = HTTPs_TOKEN_VAR_STOP[0];

            val_buf_len = Str_Len(val_buf);
            if (val_buf_len > HTTPs_CFG_MAX_VAL_LEN) {
                val_buf_len = HTTPs_CFG_MAX_VAL_LEN;
            }

                                                                /* Copy the value.                                      */
            Mem_Copy(net_buf_ptr, val_buf, val_buf_len);
            net_buf_ptr  += val_buf_len;
            file_buf_ptr += (var_end - var_start + StopTokLen);
        }
    }

                                                                /* Send HTTP header.                                    */
    mime_type = HTTPs_GetMimeType((CPU_CHAR *)".html");
    err       = HTTPs_TxHTTPHdr(conn_info, HTTP_STATUS_OK, mime_type, net_buf_len);
    if (err  == DEF_FAIL) {
        Mem_Free(net_buf);
        Mem_Free(file_buf);
        return (DEF_FAIL);
    }

                                                                /* Send the file with replaced values.                  */
    net_buf_ptr = net_buf;
    while (net_buf_ptr < (net_buf + net_buf_len)) {
        if ((net_buf + net_buf_len - net_buf_ptr) < HTTPs_MAX_PKT_SIZE) {
            tx_size = net_buf + net_buf_len - net_buf_ptr;
        } else {
            tx_size = HTTPs_MAX_PKT_SIZE;
        }

        HTTPs_Tx(conn_info->SockID, net_buf_ptr, tx_size, &net_err);
        if (net_err != NET_SOCK_ERR_NONE) {
            Mem_Free(net_buf);
            Mem_Free(file_buf);
            return (DEF_FAIL);
        }
        net_buf_ptr += tx_size;
    }

    Mem_Free(net_buf);
    Mem_Free(file_buf);
    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                         HTTPs_ProcessGetReq()
*
* Description : Process each HTTP GET requests.
*
* Argument(s) : conn_info       structure containing information about the HTTP connection.
*               file_name       file name to GET.
*
* Return(s)   : DEF_FAIL        request process failed.
*               DEF_OK          request process successful.
*
* Caller(s)   : HTTPs_ProcessReq().
*********************************************************************************************************
*/

static  CPU_BOOLEAN  HTTPs_ProcessGetReq (HTTPs_CONN_INFO  *conn_info, CPU_CHAR  *file_name)
{
    FS_FILE      *file;
    CPU_CHAR      buf[HTTPs_MAX_PKT_SIZE + 1];
    CPU_CHAR     *mime_type;
    CPU_INT32S    fs_len;
    CPU_INT32S    str_result;
    NET_ERR       net_err;
    CPU_BOOLEAN   err;
    CPU_INT32U    file_size;


                                                                /* If GET an HTML file, use HTTPs_ProcessHTMLFile() to  */
                                                                /* search for tokens.                                   */
    mime_type  = HTTPs_GetMimeType(file_name);
    str_result = Str_Cmp(mime_type, (CPU_CHAR *)"text/html");
    if (str_result == 0) {
        err = HTTPs_ProcessHTMLFile(conn_info, file_name);
        if (err == DEF_FAIL) {
            return (DEF_FAIL);
        }
        return (DEF_OK);
    }

                                                                /* Open file.                                           */
    file      = FS_FOpen((char *)file_name, "r");
    if (file == (FS_FILE *)0) {
        err = HTTPs_TxFileNotFoundMsg(conn_info);
        return (DEF_FAIL);
    }

    file_size = FS_GetFileSize(file);                           /* Get file size.                                       */
                                                                /* Send header.                                         */
    err = HTTPs_TxHTTPHdr(conn_info, HTTP_STATUS_OK, mime_type, file_size);
    if (err == DEF_FAIL) {
        FS_FClose(file);
        return (DEF_FAIL);
    }

                                                                /* Send file content to client.                         */
    do {
        fs_len = FS_FRead(buf, 1, sizeof(buf), file);

        if (fs_len > 0) {
            HTTPs_Tx(conn_info->SockID, buf, fs_len, &net_err);
            if (net_err != NET_SOCK_ERR_NONE) {
                FS_FClose(file);
                return (DEF_FAIL);
            }
        }
    } while (fs_len > 0);

    FS_FClose(file);
    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                        HTTPs_ProcessHeadReq()
*
* Description : Process each HTTP HEAD requests.
*
* Argument(s) : conn_info       structure containing information about the HTTP connection.
*               file_name       file name to get the HEAD.
*
* Return(s)   : DEF_FAIL        request process failed.
*               DEF_OK          request process successful.
*
* Caller(s)   : HTTPs_ProcessReq().
*********************************************************************************************************
*/

static  CPU_BOOLEAN  HTTPs_ProcessHeadReq (HTTPs_CONN_INFO  *conn_info, CPU_CHAR  *file_name)
{
    FS_FILE      *file;
    CPU_CHAR     *buf;
    CPU_CHAR     *mime_type;
    CPU_INT32S    fs_len;
    CPU_CHAR     *head_start;
    CPU_CHAR     *head_end;
    CPU_INT32S    head_len;
    CPU_INT32S    tx_size;
    CPU_INT32S    str_result;
    NET_ERR       net_err;
    CPU_BOOLEAN   err;
    CPU_INT32U    file_size;

                                                                /* Only HTML file should be requested for HEAD section. */
    mime_type = HTTPs_GetMimeType(file_name);
    str_result = Str_Cmp(mime_type, (CPU_CHAR *)"text/html");
    if (str_result != 0) {
        return (DEF_FAIL);
    }

                                                                /* Open file.                                           */
    file = FS_FOpen((char *)file_name, "r");
    if (file == (FS_FILE *)0) {
        err = HTTPs_TxFileNotFoundMsg(conn_info);
        return (DEF_FAIL);
    }

    file_size = FS_GetFileSize(file);                           /* Get file size.                                       */
                                                                /* Allocate buffer.                                     */
    buf = (CPU_CHAR *)Mem_Malloc(file_size + 1);
    if (buf == (CPU_CHAR *)0) {
        return (DEF_FAIL);
    }

                                                                /* Read file.                                           */
    fs_len = FS_FRead(buf, 1, file_size, file);
    FS_FClose(file);
    if (fs_len != file_size) {
        Mem_Free(buf);
        return (DEF_FAIL);
    }
    buf[fs_len] = (CPU_CHAR)0;

                                                                /* Search for HEAD tokens.                              */
    head_start = Str_Str(buf,        (CPU_CHAR *)HTTP_TOKEN_HEAD_START);
    head_end   = Str_Str(head_start, (CPU_CHAR *)HTTP_TOKEN_HEAD_STOP);
    if ((head_start == (CPU_CHAR *)0) ||
        (head_end   == (CPU_CHAR *)0)) {
        Mem_Free(buf);
        return (DEF_FAIL);
    }

                                                                /* Send header.                                         */
    err = HTTPs_TxHTTPHdr(conn_info, HTTP_STATUS_OK, mime_type, file_size);
    if (err == DEF_FAIL) {
        FS_FClose(file);
        Mem_Free(buf);
        return (DEF_FAIL);
    }

                                                                /* Send HEAD part of the file to client.                */
    head_len = head_end - head_start + Str_Len((CPU_CHAR *)HTTP_TOKEN_HEAD_STOP);
    while (head_len > 0) {
        if (head_len < HTTPs_MAX_PKT_SIZE) {
            tx_size = head_len;
        } else {
            tx_size = HTTPs_MAX_PKT_SIZE;
        }

        HTTPs_Tx(conn_info->SockID, head_start, tx_size, &net_err);
        if (net_err != NET_SOCK_ERR_NONE) {
            Mem_Free(buf);
            return (DEF_FAIL);
        }
        head_start += tx_size;
        head_len = head_end - head_start + Str_Len((CPU_CHAR *)HTTP_TOKEN_HEAD_STOP);
    }

    Mem_Free(buf);
    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                        HTTPs_ProcessPostReq()
*
* Description : Process each HTTP POST requests.
*
* Argument(s) : conn_info       structure containing information about the HTTP connection.
*               file_name       file name to apply the POST data.
*               buf             CGI string that could be appended to the request packet.
*
* Return(s)   : DEF_FAIL        request process failed.
*               DEF_OK          request process successful.
*
* Caller(s)   : HTTPs_ProcessReq().
*********************************************************************************************************
*/

static  CPU_BOOLEAN  HTTPs_ProcessPostReq (HTTPs_CONN_INFO  *conn_info, CPU_CHAR  *file_name, CPU_CHAR  *buf)
{
    CPU_CHAR     *cgi_str;
    CPU_INT32U    new_line_cnt;
    CPU_INT32S    net_len;
    NET_ERR       net_err;
    CPU_BOOLEAN   err;


                                                                /* Look for a blank line. If found, then assume that    */
                                                                /* the POST contains the follow up (name/value pairs)   */
                                                                /* also.                                                */
    cgi_str      = (CPU_CHAR *)0;
    new_line_cnt = 0;

    while (*buf != (CPU_CHAR)0) {
        if ((buf[0] == '\r') &&
            (buf[1] == '\n')) {
            buf += 2;
            new_line_cnt++;
        } else if (*buf == '\r') {
            buf++;
            new_line_cnt++;
        } else if (*buf == '\n') {
            buf++;
            new_line_cnt++;
        } else {
            new_line_cnt = 0;
        }

        if (new_line_cnt >= 2) {
            cgi_str = buf;
            break;
        }
        buf++;
    }

                                                                /* Read socket for the follow up string.                */
    if (cgi_str == (CPU_CHAR *)0) {
        net_len = NetSock_RxData(conn_info->SockID, buf, HTTPs_MAX_PKT_SIZE + 1, NET_SOCK_FLAG_NONE, &net_err);
        if ((net_err != NET_SOCK_ERR_NONE) ||
            (net_len < 0)) {
            return (DEF_FAIL);
        }
        buf[net_len] = (CPU_CHAR)0;
        cgi_str      = buf;
    }

                                                                /* Extract variables and values from the string.  Send  */
                                                                /* them to the application.                             */
    err = HTTPs_ProcessCGIList(cgi_str);
    if (err == DEF_FAIL) {
        return (DEF_FAIL);
    }

                                                                /* Send the POST file to the client.  Same logic as the */
                                                                /* GET request.                                         */
    err = HTTPs_ProcessGetReq(conn_info, file_name);
    if (err == DEF_FAIL) {
        return (DEF_FAIL);
    }
    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                          HTTPs_ProcessReq()
*
* Description : Process each HTTP requests.
*
* Argument(s) : conn_info       structure containing information about the HTTP connection.
*
* Return(s)   : DEF_FAIL        request process failed.
*               DEF_OK          request process successful.
*
* Caller(s)   : HTTPs_Task().
*********************************************************************************************************
*/

static  CPU_BOOLEAN  HTTPs_ProcessReq (HTTPs_CONN_INFO  *conn_info)
{
    CPU_CHAR      buf[HTTPs_MAX_PKT_SIZE + 1];
    CPU_INT32S    net_len;
    CPU_CHAR      web_file_name[FS_DIRNAME_MAX + 1];
    CPU_CHAR      fs_file_name[FS_DIRNAME_MAX + 1];
    CPU_CHAR     *web_file_name_ptr;
    CPU_CHAR     *ver_ptr;
    CPU_INT32U    http_method;
    CPU_INT32U    ix;
    CPU_INT32S    str_result;
    CPU_CHAR     *str_result_ptr;
    NET_ERR       net_err;
    CPU_BOOLEAN   err;


    net_len = NetSock_RxData(conn_info->SockID, buf, sizeof(buf), NET_SOCK_FLAG_NONE, &net_err);
    if ((net_err != NET_SOCK_ERR_NONE) ||
        (net_len < 0)) {
        return (DEF_FAIL);
    }
    buf[net_len] = (CPU_CHAR)0;                                 /* NULL terminate the incoming HTTP request.            */

                                                                /* Parse the HTTP request string. The format of the     */
                                                                /* first line is: [Method][ ][FileName][ ][Version].    */

                                                                /* Parse the HTTP request method.                       */
    str_result_ptr = Str_Str(buf, (CPU_CHAR *)HTTPs_Method[HTTP_METHOD_GET]);
    if (str_result_ptr != (CPU_CHAR *)0) {
        http_method = HTTP_METHOD_GET;
    } else {
        str_result_ptr = Str_Str(buf, (CPU_CHAR *)HTTPs_Method[HTTP_METHOD_HEAD]);
        if (str_result_ptr != (CPU_CHAR *)0) {
            http_method = HTTP_METHOD_HEAD;
        } else {
            str_result_ptr = Str_Str(buf, (CPU_CHAR *)HTTPs_Method[HTTP_METHOD_POST]);
            if (str_result_ptr != (CPU_CHAR *)0) {
                http_method = HTTP_METHOD_POST;
            } else {
                return (DEF_FAIL);
            }
        }
    }

                                                                /* Parse file name.                                     */
    web_file_name_ptr = Str_Char(buf, ' ');
    if (web_file_name_ptr == (CPU_CHAR *)0) {
        return (DEF_FAIL);
    } else {
        web_file_name_ptr++;
    }

    for (ix = 0; ix < sizeof(web_file_name); ix++) {
        str_result = Str_IsSpace(*web_file_name_ptr);
        if (str_result != 0) {
            break;
        }
        web_file_name[ix] = *web_file_name_ptr++;
    }
    web_file_name[ix] = (CPU_CHAR)0;

                                                                /* If no file name is specified, defaults to            */
                                                                /* HTTPS_DEFAULT_FILE.                                  */
    str_result = Str_Cmp(web_file_name, (CPU_CHAR *)"/");
    if (str_result == 0) {
        Str_Cat(web_file_name, (CPU_CHAR *)HTTPs_CFG_DFLT_FILE);
    }

                                                                /* Convert WEB-based file name into FS-base file name.  */
                                                                /* Web pages are stored in HTTPs_FS_ROOT in the server. */
    Str_Copy(fs_file_name, (CPU_CHAR *)HTTPs_CFG_FS_ROOT);
    Str_Cat(fs_file_name, web_file_name);

                                                                /* Replace '/' by '\'.                                  */
    for (ix = 0; ix < Str_Len(fs_file_name); ix++) {
        if (fs_file_name[ix] == '/') {
            fs_file_name[ix] = '\\';
        }
    }

                                                                /* Attempt to retrieve the HTTP version of the client.  */
                                                                /* The response made to the client from this server     */
                                                                /* should be dependent on the version of the client.    */
                                                                /* This server is, at best, an HTTP/1.1 server, but if  */
                                                                /* the client is an HTTP/0.9 client or HTTP/1.0,        */
                                                                /* respond with that instead.  If the client is higher  */
                                                                /* than HTTP/1.1, still respond as an HTTP/1.1 server.  */
    ver_ptr = Str_Char(web_file_name_ptr, ' ');
    if (ver_ptr == (CPU_CHAR *)0) {
        return (DEF_FAIL);
    } else {
        ver_ptr++;
    }

    str_result_ptr = Str_Str(ver_ptr, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_11]);
    if (str_result_ptr != (CPU_CHAR *)0) {
        conn_info->ClientVerNo = HTTP_VER_11;
        Str_Copy(conn_info->ClientVer, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_11]);
        Str_Copy(conn_info->ServerVer, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_11]);
    } else {
        str_result_ptr = Str_Str(ver_ptr, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_10]);
        if (str_result_ptr != (CPU_CHAR *)0) {
            conn_info->ClientVerNo = HTTP_VER_10;
            Str_Copy(conn_info->ClientVer, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_10]);
            Str_Copy(conn_info->ServerVer, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_10]);
        } else {
            str_result_ptr = Str_Str(ver_ptr, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_09]);
            if (str_result_ptr != (CPU_CHAR *)0) {
                conn_info->ClientVerNo = HTTP_VER_09;
                Str_Copy(conn_info->ClientVer, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_09]);
                Str_Copy(conn_info->ServerVer, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_09]);
            } else {
                conn_info->ClientVerNo = HTTP_VER_UNSUPPORTED;
                Str_Copy(conn_info->ClientVer, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_UNSUPPORTED]);
                Str_Copy(conn_info->ServerVer, (CPU_CHAR *)HTTPs_Ver[HTTP_VER_09]);
            }
        }
    }

                                                                /* Now do the method-specific stuff:                    */
                                                                /* GET:  Reply with specified file.                     */
                                                                /* HEAD: Reply with the data between <HEAD> and </HEAD> */
                                                                /*       in specified file (current implementation is   */
                                                                /*       not at all robust. Header should be < 1Kb.)    */
                                                                /* POST: Assume the FileName is some type of action.    */
    if (http_method == HTTP_METHOD_GET) {
        err = HTTPs_ProcessGetReq(conn_info, fs_file_name);
        if (err == DEF_FAIL) {
            return (DEF_FAIL);
        }
    } else if (http_method == HTTP_METHOD_HEAD) {
        err = HTTPs_ProcessHeadReq(conn_info, fs_file_name);
        if (err == DEF_FAIL) {
            return (DEF_FAIL);
        }
    } else if (http_method == HTTP_METHOD_POST) {
        err = HTTPs_ProcessPostReq(conn_info, fs_file_name, buf);
        if (err == DEF_FAIL) {
            return (DEF_FAIL);
        }
    }

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                             HTTPs_Task()
*
* Description : HTTP server main loop.
*
* Argument(s) : p_arg       argument passed to the task (ignored).
*
* Return(s)   : None.
*
* Caller(s)   : None.
*
* Note(s)     : This function does all the initial socket stuff for the HTTP server.  Once an incoming
*               message is received, it is passed to HTTPs_ProcessReq() for the bulk of the work.
*********************************************************************************************************
*/

void  HTTPs_Task (void  *p_arg)
{
    CPU_INT32S         listen_sock_id;
    CPU_INT32S         req_sock_id;
    NET_SOCK_ADDR      server_addr;
    NET_SOCK_ADDR      client_addr;
    CPU_INT16S         client_addr_len;
    NET_SOCK_ADDR_IP  *server_addr_ptr;
    HTTPs_CONN_INFO   *conn_info;
    NET_ERR            net_err;


    (void)p_arg;
    HTTPs_ReqCnt = 0;

    while (DEF_TRUE) {
                                                                /* Open a socket.                                       */
        listen_sock_id = NetSock_Open( NET_SOCK_ADDR_FAMILY_IP_V4,
                                       NET_SOCK_TYPE_STREAM,
                                       NET_SOCK_PROTOCOL_TCP,
                                      &net_err);
        if (net_err != NET_SOCK_ERR_NONE) {
            HTTPs_OS_TaskSuspend();
        }

                                                                /* Bind a local address so the clients can send to us.  */
        Mem_Set(&server_addr, (CPU_CHAR)0, sizeof(server_addr));
        server_addr_ptr         = (NET_SOCK_ADDR_IP *)&server_addr;
        server_addr_ptr->Family = NET_SOCK_ADDR_FAMILY_IP_V4;
        server_addr_ptr->Port   = NET_UTIL_HOST_TO_NET_16(HTTPs_CFG_IPPORT);
        server_addr_ptr->Addr   = NET_UTIL_HOST_TO_NET_32(INADDR_ANY);

        NetSock_Bind(listen_sock_id,
                     &server_addr,
                     NET_SOCK_ADDR_SIZE,
                     &net_err);
        if (net_err != NET_SOCK_ERR_NONE) {
            NetSock_Close(listen_sock_id, &net_err);
            HTTPs_OS_TaskSuspend();
        }

                                                                /* Listen to the socket for clients.                    */
        NetSock_Listen(listen_sock_id,
                       HTTPs_CONN_Q_SIZE,
                       &net_err);
        if (net_err != NET_SOCK_ERR_NONE) {
            NetSock_Close(listen_sock_id, &net_err);
            HTTPs_OS_TaskSuspend();
        }

        while (DEF_TRUE) {
                                                                /* When a client make a request, accept it and create a */
                                                                /* new socket for it.                                   */
            client_addr_len = sizeof(client_addr);

                                                                /* Wait on socket, accept with timeout.                 */
            req_sock_id     = NetSock_Accept( listen_sock_id,
                                             &client_addr,
                                             &client_addr_len,
                                             &net_err);
            switch (net_err) {
                case NET_SOCK_ERR_NONE:
                     break;

                case NET_ERR_INIT_INCOMPLETE:
                case NET_SOCK_ERR_NULL_PTR:
                case NET_SOCK_ERR_NONE_AVAIL:
                case NET_SOCK_ERR_CONN_ACCEPT_Q_NONE_AVAIL:
                case NET_SOCK_ERR_CONN_SIGNAL_TIMEOUT:
                case NET_OS_ERR_LOCK:
                     continue;                                  /* Ignore transitory socket error.                      */

                case NET_SOCK_ERR_NOT_USED:
                case NET_SOCK_ERR_INVALID_SOCK:
                case NET_SOCK_ERR_INVALID_TYPE:
                case NET_SOCK_ERR_INVALID_FAMILY:
                case NET_SOCK_ERR_INVALID_STATE:
                case NET_SOCK_ERR_INVALID_OP:
                case NET_SOCK_ERR_CONN_FAIL:
                default:
                     break;
            }

            if (net_err != NET_SOCK_ERR_NONE) {
                NetSock_Close(listen_sock_id, &net_err);        /* Close server socket on fatal error.                  */
                break;                                          /* Break accept loop, re-open socket.                   */
            }

            conn_info = (HTTPs_CONN_INFO *)Mem_Malloc(sizeof(HTTPs_CONN_INFO));
            if (conn_info == (HTTPs_CONN_INFO *)0) {
                NetSock_Close(req_sock_id, &net_err);
                continue;
            }

                                                                /* Process client request.                               */
            conn_info->ConnNbr    = ++HTTPs_ReqCnt;
            conn_info->SockID     = req_sock_id;
            conn_info->ClientAddr = client_addr;
            HTTPs_ProcessReq(conn_info);

            NetSock_Close(req_sock_id, &net_err);
            Mem_Free(conn_info);
        }

        if (net_err != NET_SOCK_ERR_NONE) {
            continue;                                           /* Re-open socket on accept errors.                     */
        }
    }
}


/*
*********************************************************************************************************
*                                             HTTPs_Init()
*
* Description : HTTP server initialization
*
* Argument(s) : None.
*
* Return(s)   : None.
*
* Caller(s)   : Application code
*********************************************************************************************************
*/

CPU_BOOLEAN  HTTPs_Init (void)
{
    CPU_BOOLEAN  rtn_value;


    rtn_value = HTTPs_OS_Init((void *)0);

    return (rtn_value);
}
	 	 			 		    	 				 	    	 	 	 		    	     	 	 	 		 	  	  	  	     	 	      	   		 	 	 	   		   			 	     			  	 	 		   	 			       	  	 	 	 	   	  		 	 	  		 		  	 	 					 	 	 	   	   	  		 	 	 			 	    		  	  			   	  		 				 		 					 	  	  	 	 				 		 	 		 		 	 	  		  	  			 				 		 
